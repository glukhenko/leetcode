# https://leetcode.com/problems/jump-game/

from typing import List


class Solution:
    def canJump(self, nums: List[int]) -> bool:
        """
        Суть решения: мы проходим с конца в начало, и рассчитываем хороший индекс. По умолчанию хороший индекс
        соответствует последнему элементу последовательности. Если вес текущего элемента превышает хороший индекс, то
        текущий элемент становится хорошим индексом.
        К примеру дано:
        [2, 3, 1, 1, 4] # последовательность
        [0, 1, 2, 3, 4] # индексы
        Вес это сумма индекса и значения. Т.е. вес второго элемента будет 4, а третьего 3.
        Если мы понимаем что из текущего элемента можно попасть к хорошему индексу, то хороший индекс перезаписывается.
        В итоге, если хороший индекс будет нулевым то значит мы сможем пропрыгать до конца последовательности.
        """
        size_nums = len(nums)
        good_index = size_nums - 1

        for i in range(size_nums - 2, -1, -1):
            reach = nums[i] + i
            if reach >= good_index:
                good_index = i

        return good_index == 0



if __name__ == '__main__':
    nums = [2, 3, 1, 1, 4]
    expected = True
    print(Solution().canJump(nums))
